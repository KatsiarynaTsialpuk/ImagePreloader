{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///imagePreloader.min.js","webpack:///webpack/bootstrap 4b9dd5c4ca3f7d200e39","webpack:///./src/index.js","webpack:///./src/main.js","webpack:///./~/promise-ext-settled/src/main.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","ImagePreloader","fallbackImage","onProgress","HTMLImageElement","simplePreload","imageSource","Promise","resolve","reject","img","complete","naturalHeight","onload","bind","onerror","onabort","Image","src","prototype","preload","args","that","imagesToLoad","Array","concat","apply","slice","arguments","map","brokenImage","then","setAttribute","allSettled","__WEBPACK_AMD_DEFINE_RESULT__","global","inject","PromiseConstructor","extName","Error","promises","promise","value","status","e","Function","all","self","undefined"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,UAAAH,GACA,gBAAAC,SACAA,QAAA,eAAAD,IAEAD,EAAA,eAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDgBM,SAASL,EAAQD,EAASM,GEjDhCL,EAAAD,QAAAM,EAAA,IF6DM,SAASL,EAAQD,EAASM,GG7DhCA,EAAA,IAWA,IAAAS,GAAA,SAAAC,EAAAC,GAIAb,KAAAa,WAAA,kBAAAA,KAAA,KAIAb,KAAAY,cAAA,gBAAAA,gBAAAE,kBAAAF,EAAA,KAUAD,GAAAI,cAAA,SAAAC,GACA,UAAAC,SAAA,SAAAC,EAAAC,GACA,GAAAC,EAEAJ,aAAAF,mBACAM,EAAAJ,EAEAI,EAAAC,SAGaD,EAAAE,cACbJ,EAAAE,GAEAD,EAAAC,IALAA,EAAAG,OAAAL,EAAAM,KAAA,KAAAJ,GACAA,EAAAK,QAAAL,EAAAM,QAAAP,EAAAK,KAAA,KAAAJ,KAMS,gBAAAJ,KACTI,EAAA,GAAAO,OACAP,EAAAG,OAAAL,EAAAM,KAAA,KAAAJ,GACAA,EAAAK,QAAAL,EAAAM,QAAAP,EAAAK,KAAA,KAAAJ,GACAA,EAAAQ,IAAAZ,MA2BAL,EAAAkB,UAAAC,QAAA,SAAAC,GACA,GAAAC,GAAAhC,KACAiC,EAAAC,MAAAL,UAAAM,OAAAC,SAAAF,MAAAL,UAAAQ,MAAA9B,KAAA+B,WAoBA,OAlBAL,KAAAM,IAAA,SAAAvB,GACA,MAAAL,GAAAI,cAAAC,GAAAL,SAAA,SAAA6B,GACA,MAAAR,GAAApB,cACAD,EAAAI,cAAAiB,EAAApB,eACA6B,KAAA,SAAA7B,GAIA,MAHA4B,GAAAE,aAAA,gBAAAF,EAAAZ,KACAY,EAAAZ,IAAAhB,EAAAgB,IAEAY,GACqB,WACrB,MAAAvB,SAAAE,OAAAqB,KAIAvB,QAAAE,OAAAqB,OAIAvB,QAAA0B,WAAAV,EAAAD,EAAAnB,aAGAhB,EAAAD,QAAAe,GHyEM,SAASd,EAAQD,EAASM,GAE/B,GAAI0C,IIpLL,SAAAC,IAKA,WAYA,QAAAC,GAAAC,EAAAC,GAWA,GAVA,gBAAAD,KACAC,EAAAD,GAGAC,EAAA,gBAAAA,KAAA,aAEAD,EACA,kBAAAA,OACA,kBAAA9B,mBAAA,MAEA8B,EACA,SAAAE,OAAA,kEAuCA,OAxBAF,GAAAC,GAAA,SAAAE,EAAArC,GAqBA,MApBAqC,KAAAX,IAAA,SAAAY,GACA,MAAAA,GAAAV,KAAA,SAAAW,GACA,OACAA,QACAC,QAAA,IAEK,SAAAC,GACL,OACAF,MAAAE,EACAD,QAAA,KAEKZ,KAAA,SAAAW,GAKL,MAJAvC,aAAA0C,WACA1C,EAAAuC,GAGAA,MAIAnC,QAAAuC,IAAAN,IAGAH,EAGA,gBAAAU,+BACA,gBAAAZ,mBAGAD,GAAA,WACA,MAAAE,IACGvC,KAAAX,EAAAM,EAAAN,EAAAC,KAAA6D,SAAAd,IAAA/C,EAAAD,QAAAgD,SJ4L2BrC,KAAKX,EAAU,WAAa,MAAOI","file":"imagePreloader.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"imagePreloader\"] = factory();\n\telse\n\t\troot[\"imagePreloader\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"imagePreloader\"] = factory();\n\telse\n\t\troot[\"imagePreloader\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @licence MIT\n\t * @author Sergey Melyukov\n\t */\n\t\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @licence MIT\n\t * @author Sergey Melyukov\n\t */\n\t\n\t__webpack_require__(2)();\n\t\n\t/**\n\t * Image preloader\n\t *\n\t * @class ImagePreloader\n\t * @constructor\n\t *\n\t * @param {(String|HTMLImageElement)=} fallbackImage\n\t * @param {function({status:boolean, value:HTMLImageElement})=} onProgress\n\t */\n\tvar ImagePreloader = function(fallbackImage, onProgress) {\n\t    /**\n\t     * @type {?function({status: boolean, value: HTMLImageElement})}\n\t     */\n\t    this.onProgress = typeof onProgress === 'function' ? onProgress : null;\n\t    /**\n\t     * @type {?String|HTMLImageElement}\n\t     */\n\t    this.fallbackImage = typeof fallbackImage === 'string' || fallbackImage instanceof HTMLImageElement ? fallbackImage : null;\n\t};\n\t\n\t/**\n\t * Do simple image preloading.\n\t *\n\t * @param {!(String|HTMLImageElement)} imageSource\n\t *\n\t * @return {Promise} will be resolved/rejected with HTMLImageElement\n\t */\n\tImagePreloader.simplePreload = function(imageSource) {\n\t    return new Promise(function(resolve, reject) {\n\t        var img;\n\t\n\t        if (imageSource instanceof HTMLImageElement) {\n\t            img = imageSource;\n\t\n\t            if (!img.complete) {\n\t                img.onload = resolve.bind(null, img);\n\t                img.onerror = img.onabort = reject.bind(null, img);\n\t            } else if (img.naturalHeight) {\n\t                resolve(img);\n\t            } else {\n\t                reject(img);\n\t            }\n\t        } else if (typeof imageSource === 'string') {\n\t            img = new Image();\n\t            img.onload = resolve.bind(null, img);\n\t            img.onerror = img.onabort = reject.bind(null, img);\n\t            img.src = imageSource;\n\t        }\n\t    });\n\t};\n\t\n\t/**\n\t * Preload image.\n\t *\n\t * If fallbackImage-property is defined and correct, then src-attribute for the broken images will replaced by fallbackImage\n\t * As well, origin image url will be placed to 'data-fail-src' attribute.\n\t *\n\t * If onProgress-method is defined, then this method will be calling for every image loading (fulfilled of rejected).\n\t *\n\t * @param {...(String|HTMLImageElement|Array<String|HTMLImageElement>)} args\n\t *\n\t * @return {Promise} will be resolved with Array<{status:boolean, value:HTMLImageElement}>\n\t *\n\t *     status-property - is the status of image loading\n\t *     status-property will be true if:\n\t *      - original image loading is ok\n\t *      - or original image loading is fail but fallback-image loading is ok\n\t *     status-property will be false if:\n\t *      - original image loading is fail\n\t *      - or original image loading is fail and fallback-image loading is fail\n\t *\n\t *     value-property - is the image that was loaded\n\t */\n\tImagePreloader.prototype.preload = function(args) {\n\t    var that = this,\n\t        imagesToLoad = Array.prototype.concat.apply([], Array.prototype.slice.call(arguments));\n\t\n\t    imagesToLoad = imagesToLoad.map(function(imageSource) {\n\t        return ImagePreloader.simplePreload(imageSource).catch(function(brokenImage) {\n\t            if (that.fallbackImage) {\n\t                return ImagePreloader.simplePreload(that.fallbackImage)\n\t                    .then(function(fallbackImage) {\n\t                        brokenImage.setAttribute('data-fail-src', brokenImage.src);\n\t                        brokenImage.src = fallbackImage.src;\n\t\n\t                        return brokenImage;\n\t                    }, function() {\n\t                        return Promise.reject(brokenImage);\n\t                    });\n\t            }\n\t\n\t            return Promise.reject(brokenImage);\n\t        });\n\t    });\n\t\n\t    return Promise.allSettled(imagesToLoad, that.onProgress);\n\t};\n\t\n\tmodule.exports = ImagePreloader;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * @licence\n\t * @author Sergey Melyukov 2016\n\t */\n\t\n\t(function() {\n\t\t/**\n\t\t * Inject method with name `extName` to `PromiseConstructor`\n\t\t *\n\t\t * @param {Function|String=} PromiseConstructor which constructor should be extended\n\t\t *                           If not defined, then default promise-constructor will be used\n\t\t * @param {String=} extName name of the method. If not defined, then 'allSettled' will be used\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t * @throws {Error}\n\t\t */\n\t\tfunction inject(PromiseConstructor, extName) {\n\t\t\tif (typeof PromiseConstructor === 'string') {\n\t\t\t\textName = PromiseConstructor;\n\t\t\t}\n\t\n\t\t\textName = typeof extName === 'string' ? extName : 'allSettled';\n\t\n\t\t\tPromiseConstructor =\n\t\t\t\t(typeof PromiseConstructor === 'function' && PromiseConstructor) ||\n\t\t\t\t(typeof Promise === 'function' && Promise) || null;\n\t\n\t\t\tif (!PromiseConstructor) {\n\t\t\t\tthrow new Error('Wrong constructor is passed or browser doesn\\'t support promises');\n\t\t\t}\n\t\n\t\t\t/**\n\t\t\t * Waiting while all promises will be settled to onFulfilled or onRejected state\n\t\t\t * Returned promise will be resolved with array with info for every passed promise:\n\t\t\t * Array<{status:boolean, value:*}>\n\t\t\t *\n\t\t\t * onProgress-function will be called (if passed) for every settled promise\n\t\t\t *\n\t\t\t * @param {Array<Promise>} promises\n\t\t\t * @param {function({status:boolean, value:*})} onProgress\n\t\t\t *\n\t\t\t * @return {Promise}\n\t\t\t */\n\t\t\tPromiseConstructor[extName] = function(promises, onProgress) {\n\t\t\t\tpromises = promises.map(function(promise) {\n\t\t\t\t\treturn promise.then(function(value) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\t\tstatus: true\n\t\t\t\t\t\t};\n\t\t\t\t\t}, function(e) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tvalue: e,\n\t\t\t\t\t\t\tstatus: false\n\t\t\t\t\t\t};\n\t\t\t\t\t}).then(function(value) {\n\t\t\t\t\t\tif (onProgress instanceof Function) {\n\t\t\t\t\t\t\tonProgress(value);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\n\t\t\t\treturn Promise.all(promises);\n\t\t\t};\n\t\n\t\t\treturn PromiseConstructor;\n\t\t}\n\t\n\t\tvar root = (typeof self == 'object' && self.self === self && self) ||\n\t\t\t(typeof global == 'object' && global.global === global && global);\n\t\n\t\tif (true) {\n\t\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\t\treturn inject;\n\t\t\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t} else if (typeof module === 'object' && module && module.exports) {\n\t\t\tmodule.exports = inject;\n\t\t} else {\n\t\t\troot.PromiseSettled = inject;\n\t\t}\n\t})();\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** imagePreloader.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 4b9dd5c4ca3f7d200e39\n **/","/**\n * @licence MIT\n * @author Sergey Melyukov\n */\n\nmodule.exports = require('./main');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","/**\n * @licence MIT\n * @author Sergey Melyukov\n */\n\nrequire('promise-ext-settled')();\n\n/**\n * Image preloader\n *\n * @class ImagePreloader\n * @constructor\n *\n * @param {(String|HTMLImageElement)=} fallbackImage\n * @param {function({status:boolean, value:HTMLImageElement})=} onProgress\n */\nvar ImagePreloader = function(fallbackImage, onProgress) {\n    /**\n     * @type {?function({status: boolean, value: HTMLImageElement})}\n     */\n    this.onProgress = typeof onProgress === 'function' ? onProgress : null;\n    /**\n     * @type {?String|HTMLImageElement}\n     */\n    this.fallbackImage = typeof fallbackImage === 'string' || fallbackImage instanceof HTMLImageElement ? fallbackImage : null;\n};\n\n/**\n * Do simple image preloading.\n *\n * @param {!(String|HTMLImageElement)} imageSource\n *\n * @return {Promise} will be resolved/rejected with HTMLImageElement\n */\nImagePreloader.simplePreload = function(imageSource) {\n    return new Promise(function(resolve, reject) {\n        var img;\n\n        if (imageSource instanceof HTMLImageElement) {\n            img = imageSource;\n\n            if (!img.complete) {\n                img.onload = resolve.bind(null, img);\n                img.onerror = img.onabort = reject.bind(null, img);\n            } else if (img.naturalHeight) {\n                resolve(img);\n            } else {\n                reject(img);\n            }\n        } else if (typeof imageSource === 'string') {\n            img = new Image();\n            img.onload = resolve.bind(null, img);\n            img.onerror = img.onabort = reject.bind(null, img);\n            img.src = imageSource;\n        }\n    });\n};\n\n/**\n * Preload image.\n *\n * If fallbackImage-property is defined and correct, then src-attribute for the broken images will replaced by fallbackImage\n * As well, origin image url will be placed to 'data-fail-src' attribute.\n *\n * If onProgress-method is defined, then this method will be calling for every image loading (fulfilled of rejected).\n *\n * @param {...(String|HTMLImageElement|Array<String|HTMLImageElement>)} args\n *\n * @return {Promise} will be resolved with Array<{status:boolean, value:HTMLImageElement}>\n *\n *     status-property - is the status of image loading\n *     status-property will be true if:\n *      - original image loading is ok\n *      - or original image loading is fail but fallback-image loading is ok\n *     status-property will be false if:\n *      - original image loading is fail\n *      - or original image loading is fail and fallback-image loading is fail\n *\n *     value-property - is the image that was loaded\n */\nImagePreloader.prototype.preload = function(args) {\n    var that = this,\n        imagesToLoad = Array.prototype.concat.apply([], Array.prototype.slice.call(arguments));\n\n    imagesToLoad = imagesToLoad.map(function(imageSource) {\n        return ImagePreloader.simplePreload(imageSource).catch(function(brokenImage) {\n            if (that.fallbackImage) {\n                return ImagePreloader.simplePreload(that.fallbackImage)\n                    .then(function(fallbackImage) {\n                        brokenImage.setAttribute('data-fail-src', brokenImage.src);\n                        brokenImage.src = fallbackImage.src;\n\n                        return brokenImage;\n                    }, function() {\n                        return Promise.reject(brokenImage);\n                    });\n            }\n\n            return Promise.reject(brokenImage);\n        });\n    });\n\n    return Promise.allSettled(imagesToLoad, that.onProgress);\n};\n\nmodule.exports = ImagePreloader;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\n * @licence\n * @author Sergey Melyukov 2016\n */\n\n(function() {\n\t/**\n\t * Inject method with name `extName` to `PromiseConstructor`\n\t *\n\t * @param {Function|String=} PromiseConstructor which constructor should be extended\n\t *                           If not defined, then default promise-constructor will be used\n\t * @param {String=} extName name of the method. If not defined, then 'allSettled' will be used\n\t *\n\t * @returns {Function}\n\t *\n\t * @throws {Error}\n\t */\n\tfunction inject(PromiseConstructor, extName) {\n\t\tif (typeof PromiseConstructor === 'string') {\n\t\t\textName = PromiseConstructor;\n\t\t}\n\n\t\textName = typeof extName === 'string' ? extName : 'allSettled';\n\n\t\tPromiseConstructor =\n\t\t\t(typeof PromiseConstructor === 'function' && PromiseConstructor) ||\n\t\t\t(typeof Promise === 'function' && Promise) || null;\n\n\t\tif (!PromiseConstructor) {\n\t\t\tthrow new Error('Wrong constructor is passed or browser doesn\\'t support promises');\n\t\t}\n\n\t\t/**\n\t\t * Waiting while all promises will be settled to onFulfilled or onRejected state\n\t\t * Returned promise will be resolved with array with info for every passed promise:\n\t\t * Array<{status:boolean, value:*}>\n\t\t *\n\t\t * onProgress-function will be called (if passed) for every settled promise\n\t\t *\n\t\t * @param {Array<Promise>} promises\n\t\t * @param {function({status:boolean, value:*})} onProgress\n\t\t *\n\t\t * @return {Promise}\n\t\t */\n\t\tPromiseConstructor[extName] = function(promises, onProgress) {\n\t\t\tpromises = promises.map(function(promise) {\n\t\t\t\treturn promise.then(function(value) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tstatus: true\n\t\t\t\t\t};\n\t\t\t\t}, function(e) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue: e,\n\t\t\t\t\t\tstatus: false\n\t\t\t\t\t};\n\t\t\t\t}).then(function(value) {\n\t\t\t\t\tif (onProgress instanceof Function) {\n\t\t\t\t\t\tonProgress(value);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn value;\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treturn Promise.all(promises);\n\t\t};\n\n\t\treturn PromiseConstructor;\n\t}\n\n\tvar root = (typeof self == 'object' && self.self === self && self) ||\n\t\t(typeof global == 'object' && global.global === global && global);\n\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine(function() {\n\t\t\treturn inject;\n\t\t});\n\t} else if (typeof module === 'object' && module && module.exports) {\n\t\tmodule.exports = inject;\n\t} else {\n\t\troot.PromiseSettled = inject;\n\t}\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/promise-ext-settled/src/main.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}